import os
import json
import math
import random
import copy

# --- CONFIGURATION ---
MAX_ITERATIONS = 50
LEARNING_RATE = 0.6  # Probability of adjusting a position to match gBest per cycle

def load_data():
    """
    Loads test case data. Priorities:
    1. llm.txt (Generated by prompt_gemini.py)
    """
    test_cases = []
    
    if os.path.exists("llm.txt"):
        try:
            with open("llm.txt", "r") as f:
                data = json.load(f)
                for test_id, attrs in data.items():
                    test_cases.append({
                        'id': test_id,
                        'amplitude': float(attrs.get('relevance', 0.5)),
                        'frequency': float(attrs.get('complexity', 0.5)),
                    })
            print(f"Loaded {len(test_cases)} cases from llm.txt")
            return test_cases
        except Exception as e:
            print(f"Error reading llm.txt: {e}")

    print("No input files found.")

def calculate_phase(rank, n):
    """
    Calculates phase based on position (rank).
    Formula: Phase = (Rank + 1) / n * PI
    Rank is 0-indexed (0 to n-1).
    Result is in (0, PI].
    """
    if n == 0: return 0
    return (rank / n) * 2 * math.pi

def interference_aware_fitness(permutation, test_cases_lookup):
    """
    Calculates fitness by simulating the Superposition of Waves.
    We sum the waves at time steps t=1 to N.
    """
    
    # We evaluate the wave over a time window equal to the number of tests
    time_steps = len(permutation) 
    total_energy = 0.0
    
    # Loop through Time (t=1, t=2...)
    for t in range(1, time_steps + 1):
        current_superposition = 0.0
        
        # Sum the waves for ALL test cases at this specific time 't'
        for position_index, test_id in enumerate(permutation):
            test_case = test_cases_lookup[test_id]
            
            A = test_case['amplitude']  # Relevance
            w = test_case['frequency']  # Complexity
            
            phi = calculate_phase(position_index, time_steps) 
            
            # Calculate individual wave: A * cos(w*t + phi)
            wave_val = A * math.cos(w * t + phi)
            
            # Add to the superposition for this time slot
            current_superposition += wave_val
            
        # Calculate Energy at this time step
        # We just sum raw values, negatives cancel positives (Destructive).
        total_energy += current_superposition
        
        # If we square the result because we want only "Constructive Interference" (High Energy).
        # Maximizing (Sum^2) finds the order where peaks align best.
        # total_energy += (current_superposition ** 2)

    return total_energy

class DiscretePhasePSO:
    def __init__(self, test_cases):
        self.test_cases = test_cases
        self.num_tests = len(test_cases)
        # Lookup map for fitness calc
        self.tc_map = {t['id']: t for t in test_cases}
        self.ids = [t['id'] for t in test_cases]
        
        self.particles = []
        self.pbest = []
        self.pbest_scores = []
        
        self.gbest = []
        self.gbest_score = 0.0
        
        self.initialize_particles()

    def initialize_particles(self):
        """
        Cycle 1 Initialization (Stratified):
        Particle 1 starts with Test A in Pos 1.
        Particle 2 starts with Test B in Pos 1.
        ...
        The rest follow the natural order.
        """
        # Ensure we have N particles for N tests
        for i in range(self.num_tests):
            # Start with test[i]
            leading_test = self.ids[i]
            # Rest are the others in original order
            rest = [tid for k, tid in enumerate(self.ids) if k != i]
            
            sequence = [leading_test] + rest
            self.particles.append(sequence)
            
            # Initial Pbest is the starting state
            self.pbest.append(sequence[:])
            self.pbest_scores.append(0.0) # Will calc in first optimize step

    def update_particle(self, particle_idx):
        """
        Moves particle toward gBest by swapping.
        """
        current_seq = self.particles[particle_idx]
        target_seq = self.gbest
        
        # Create a copy to modify
        new_seq = current_seq[:]
        
        # Iterate through positions
        for i in range(self.num_tests):
            # If mismatch, try to fix it
            if new_seq[i] != target_seq[i]:
                # Probabilistic update (Learning Rate)
                if random.random() < LEARNING_RATE:
                    # needed value
                    needed_val = target_seq[i]
                    # find where it is currently
                    current_pos_of_val = new_seq.index(needed_val)
                    
                    # Swap current[i] with current[current_pos_of_val]
                    # This puts the correct value in position i
                    new_seq[i], new_seq[current_pos_of_val] = new_seq[current_pos_of_val], new_seq[i]
                    
        self.particles[particle_idx] = new_seq

    def optimize(self):
        print(f"Initializing {len(self.particles)} particles...")
        
        # Cycle 1: Evaluation
        for i in range(len(self.particles)):
            fit = interference_aware_fitness(self.particles[i], self.tc_map)
            
            # Update Pbest (First run, always update)
            self.pbest[i] = self.particles[i][:]
            self.pbest_scores[i] = fit
            
            # Update Gbest
            if fit > self.gbest_score:
                self.gbest_score = fit
                self.gbest = self.particles[i][:]
        
        print(f"Cycle 1 Complete. Best Score: {self.gbest_score:.4f}")

        # Main Loop (Cycle 2+)
        for cycle in range(2, MAX_ITERATIONS + 1):
            for i in range(len(self.particles)):
                # Move
                self.update_particle(i)
                
                # Evaluate
                fit = interference_aware_fitness(self.particles[i], self.tc_map)
                
                # Check Pbest
                if fit > self.pbest_scores[i]:
                    self.pbest_scores[i] = fit
                    self.pbest[i] = self.particles[i][:]
                    
                    # Check Gbest
                    if fit > self.gbest_score:
                        self.gbest_score = fit
                        self.gbest = self.particles[i][:]
            
            # Optional: Print progress
            if cycle % 10 == 0:
                print(f"Cycle {cycle}: Best Score = {self.gbest_score:.4f}")
                
        return self.gbest

def generate_report(best_sequence, tc_map, n):
    report = "# Discrete Phase PSO Prioritization Results\n\n"
    report += "| Priority | Test Case ID | Amplitude | Frequency | Phase (rad) |\n"
    report += "|---|---|---|---|---|\n"
    
    for rank, tid in enumerate(best_sequence):
        t = tc_map[tid]
        phase = calculate_phase(rank, n)
        
        report += f"| {rank+1} | {t['id']} | {t['amplitude']:.2f} | {t['frequency']:.2f} | {phase:.3f} |\n"
        
    report += "\n\n**Algorithm Configuration:**\n"
    report += f"- Particles: {n}\n"
    report += f"- Cycles: {MAX_ITERATIONS}\n"
    report += f"- Learning Rate: {LEARNING_RATE}\n"
    
    with open("prioritization_report.md", "w") as f:
        f.write(report)

def main():
    test_cases = load_data()
    if not test_cases:
        return

    print("--- Starting Discrete Phase PSO ---")
    pso = DiscretePhasePSO(test_cases)
    best_seq = pso.optimize()
    
    generate_report(best_seq, pso.tc_map, len(test_cases))
    print("Optimization Complete. Report generated.")

if __name__ == "__main__":
    main()