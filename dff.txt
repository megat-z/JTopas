diff --git a/.github/workflows/git-diff.yml b/.github/workflows/git-diff.yml
index c25543b..6222990 100644
--- a/.github/workflows/git-diff.yml
+++ b/.github/workflows/git-diff.yml
@@ -1,64 +1,78 @@
 name: Git Diff Extraction
 
 on:
-    repository_dispatch:
-        types: [git-diff]
+  repository_dispatch:
+    types: [git-diff]
 
 jobs:
-    extract-changes:
-        runs-on: ubuntu-latest
-        permissions:
-            contents: write
+  extract-changes:
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
 
-        steps:
-            - name: Checkout Repository
-              uses: actions/checkout@v4
-              with:
-                  ref: ${{ github.event.client_payload.branch }}
-                  fetch-depth: 10
+    steps:
+      - name: Checkout Repository
+        uses: actions/checkout@v4
+        with:
+          ref: ${{ github.event.client_payload.branch }}
+          fetch-depth: 15 # Fetch enough depth to find the history
 
-            - name: Extract Git Diff (Benchmark Search)
-              shell: bash
-              run: |
-                  # 1. Search for the specific benchmark commits
-                  echo "Searching history for 'Commit 1' or 'Commit 2'..."
+      - name: Validate and Extract Diff
+        shell: bash
+        run: |
+          # 1. Verify HEAD is 'Commit 2'
+          CURRENT_MSG=$(git log -1 --format="%s" HEAD)
+          echo "Current Commit Message: '$CURRENT_MSG'"
 
-                  TARGET_COMMIT=""
+          if [[ "$CURRENT_MSG" != "Commit 2" ]]; then
+            echo "âŒ Error: The latest commit is not 'Commit 2'. Aborting."
+            exit 1
+          fi
+          echo "âœ… HEAD validation passed."
 
-                  for i in {0..9}; do
-                    # Get the commit message subject for HEAD~i
-                    MSG=$(git log -1 --format="%s" HEAD~$i)
-                    
-                    if [[ "$MSG" == "Commit 1" || "$MSG" == "Commit 2" ]]; then
-                      echo "âœ… Found benchmark checkpoint at HEAD~$i: '$MSG'"
-                      TARGET_COMMIT="HEAD~$i"
-                      break
-                    fi
-                  done
+          # 2. Find the most recent 'Commit 1' in the last 10 commits
+          BENCHMARK_HASH=""
+          
+          echo "Searching history for 'Commit 1'..."
+          
+          # Loop through HEAD~1 to HEAD~10
+          for i in {1..10}; do
+            # Get hash and message of the ancestor commit
+            HASH=$(git rev-parse HEAD~$i)
+            MSG=$(git log -1 --format="%s" $HASH)
 
-                  # 2. Generate Diff or Fail
-                  if [ -z "$TARGET_COMMIT" ]; then
-                    echo "âš ï¸  Could not find 'Commit 1' or 'Commit 2' in the last 20 commits."
-                    echo "No benchmark commit found"
-                  else
-                    echo "ðŸ“ Extracting diff for commit $TARGET_COMMIT..."
-                    # We exclude artifact files just in case, but primarily rely on the specific commit selection
-                    git diff ${TARGET_COMMIT}^ ${TARGET_COMMIT} -- . ':!dff.txt' ':!llm.txt' ':!tca.json' ':!prioritization_report.md' > dff.txt
-                  fi
+            if [[ "$MSG" == "Commit 1" ]]; then
+              echo "âœ… Found benchmark 'Commit 1' at HEAD~$i ($HASH)"
+              BENCHMARK_HASH=$HASH
+              break
+            fi
+          done
 
-                  echo "Diff size: $(wc -c < dff.txt) bytes"
+          # 3. Generate Diff (Commit 1 -> Commit 2)
+          if [ -z "$BENCHMARK_HASH" ]; then
+            echo "âš ï¸ Could not find 'Commit 1' within the last 10 commits."
+            exit 1
+          else
+            echo "ðŸ“ Extracting diff between $BENCHMARK_HASH (Commit 1) and HEAD (Commit 2)..."
+            
+            # Diff changes FROM benchmark TO head
+            git diff $BENCHMARK_HASH HEAD -- . ':!dff.txt' ':!llm.txt' ':!tca.json' ':!prioritization_report.md' > dff.txt
+            
+            echo "Diff generated successfully."
+            echo "Diff size: $(wc -c < dff.txt) bytes"
+          fi
 
-            - name: Commit Diff Artifact
-              run: |
-                  git config --global user.name 'JTopas Automation'
-                  git config --global user.email 'automation@jtopas.local'
+      - name: Commit Diff Artifact
+        run: |
+          git config --global user.name 'JTopas Automation'
+          git config --global user.email 'automation@jtopas.local'
 
-                  git add dff.txt
+          git add dff.txt
 
-                  if git diff --staged --quiet; then
-                    echo "No changes to dff.txt. Skipping commit."
-                  else
-                    git commit -m "chore: update dff.txt [skip ci]"
-                    git pull origin ${{ github.event.client_payload.branch }} --rebase
-                    git push origin ${{ github.event.client_payload.branch }}
-                  fi
\ No newline at end of file
+          if git diff --staged --quiet; then
+            echo "No changes to dff.txt. Skipping commit."
+          else
+            git commit -m "chore: update dff.txt [skip ci]"
+            git pull origin ${{ github.event.client_payload.branch }} --rebase
+            git push origin ${{ github.event.client_payload.branch }}
+          fi
\ No newline at end of file
diff --git a/.github/workflows/prompt-llm.yml b/.github/workflows/prompt-llm.yml
index 6e9dba0..cc69470 100644
--- a/.github/workflows/prompt-llm.yml
+++ b/.github/workflows/prompt-llm.yml
@@ -37,6 +37,6 @@ jobs:
                   git config --global user.name 'JTopas Automation'
                   git config --global user.email 'automation@jtopas.local'
                   git add llm.txt
-                  # This commit triggers GAS to detect 'llm.txt' and fire 'calc-mpltd'
+                  # This commit triggers GAS to detect 'llm.txt' and run 'qi-pso'
                   git commit -m "chore: update llm.txt [skip ci]"
                   git push
diff --git a/susebox/java/io/ExtIOException.class b/susebox/java/io/ExtIOException.class
new file mode 100644
index 0000000..467f369
Binary files /dev/null and b/susebox/java/io/ExtIOException.class differ
diff --git a/susebox/java/io/ExtIOException.java b/susebox/java/io/ExtIOException.java
index 877f9e5..4c71ed0 100644
--- a/susebox/java/io/ExtIOException.java
+++ b/susebox/java/io/ExtIOException.java
@@ -33,10 +33,10 @@ package de.susebox.java.io;
 //------------------------------------------------------------------------------
 // Imports
 //
-import java.text.MessageFormat;
 import java.io.IOException;
 
 import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 
 
 //------------------------------------------------------------------------------
@@ -58,13 +58,11 @@ public class ExtIOException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link de.susebox.java.lang.ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
-   */  
+   */
   public Exception nextException() {
 		return _next;
 	}
@@ -80,6 +78,28 @@ public class ExtIOException
 		return _isWrapper;
 	}
 
+  /**
+   * Getting the format string of a exception message. This can also be the
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }  
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
 
   //---------------------------------------------------------------------------
   // constructors
@@ -153,10 +173,16 @@ public class ExtIOException
    * @param fmt   exception message
    * @param args  arguments for the given format string
    */  
-	public ExtIOException(Exception ex, String msg, Object[] args) {
-		super(msg);
-		_next      = ex;
-		_isWrapper = true;
+	public ExtIOException(Exception ex, String fmt, Object[] args) {
+    super(fmt);
+   
+    if (ex != null && fmt == null) {
+      _isWrapper = true;
+    } else {
+      _isWrapper = false;
+    }
+    _next = ex;
+    _args = args;
 	}
 
 
@@ -165,37 +191,36 @@ public class ExtIOException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to 
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped 
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.langThrowable#getMessage} method. It
+   * delegates the call to the central 
+   * {@link de.susebox.java.lang.ExceptionMessageFormatter#getMessage} method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
-   */  
+   * @see     de.susebox.java.lang.ExceptionMessageFormatter
+   */
 	public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
 	}
 
   
   //---------------------------------------------------------------------------
   // members
   //
+
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/java/lang/ExceptionList.class b/susebox/java/lang/ExceptionList.class
new file mode 100644
index 0000000..36fc9a8
Binary files /dev/null and b/susebox/java/lang/ExceptionList.class differ
diff --git a/susebox/java/lang/ExceptionList.java b/susebox/java/lang/ExceptionList.java
index b0c3b24..2c90b00 100644
--- a/susebox/java/lang/ExceptionList.java
+++ b/susebox/java/lang/ExceptionList.java
@@ -35,9 +35,8 @@ package de.susebox.java.lang;
 //
 
 /*-->
-import java.text.MessageFormat;
- 
 import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 -->*/
 
 
@@ -69,11 +68,29 @@ import de.susebox.java.lang.ExceptionList;
  * @author 	Heiko Blau
  */
 public interface ExceptionList {
+  
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
+   * Method to traverse the exception list. By convention, <code>nextException</code>>
    * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
+   * the following meaning:
+   *<br>
    * this happened because nextException happened because nextException happened...
+   *<br>
+   * The next exception has usually one of the following meaning:
+   *<br><ul><li>
+   *  It is the "real" exception. An interface implementation might be allowed to 
+   *  throw only <code>IOException</code>, but actually has to pass on a 
+   *  <code>SQLException</code>. That ould be done by wrapping the <code>SQLException</code>
+   *  into the <code>IOException</code>.
+   *</li><li>
+   *  The next exception is "deeper" cause of this one (often called a nested
+   *  exception). A file couldn't be read in the first place and therefore not be 
+   *  attached to a mail. Both this exception and the one nested inside have their
+   *  own message.
+   *</li></li>
+   *  There are more than one basic exception to be propagated. A simple parser 
+   *  might return all syntax errors in one exception list.
+   *</li><ul>
    *
    * @return the "earlier" exception
    */
@@ -99,11 +116,52 @@ public interface ExceptionList {
   }
   -->*/
   
+  /**
+   * Getting the format string of a exception message. This can also be the 
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat();
+  /*-->
+  {
+    return super.getMessage();
+  }
+  -->*/
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments();
+  /*-->
+  {
+    return _args;
+  }
+  -->*/
+  
   
   //---------------------------------------------------------------------------
   // implementation code templates
   //
   
+  /**
+   * This constructor takes a simple message string like ordinary Java exceptions.
+   * This is the most convenient form to construct an <code>ExceptionList</code>
+   * exception.
+   *
+   * @param msg   exception message
+   */
+  /*-->
+  public <<WHICH>>Exception(String msg) {
+    this(null, msg, null);
+  }
+  -->*/
+  
   /**
    * This constructor should be used for wrapping another exception. While reading
    * data an IOException may occur, but a certain interface requires a
@@ -158,7 +216,7 @@ public interface ExceptionList {
    *    new MyException(fmt, args).getMessage();
    *<CODE>
    *
-   * @param fmt   exception message
+   * @param fmt   exception message format
    * @param args  arguments for the given format string
    */
   /*-->
@@ -188,44 +246,54 @@ public interface ExceptionList {
       _isWrapper = false;
     }
     _next = ex;
+    _args = args;
   }
   -->
    
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to
+   * Implementation of the standard {@link java.lang.Throwable#getMessage} method to
    * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * exceptions.<br>
+   * If this is a wrapper exception then the <code>getMessage</code> of the wrapped
+   * exception is returned.<br>
+   * If this is not a wrapper exception: if no arguments were given in the 
+   * constructor then the format parameter is taken as the formatted message itself. 
+   * Otherwise it is treated like the patter for the {@link java.text.MessageFormat#format}
+   * method.
    *
    * @return  the formatted exception message
    * @see     java.text.MessageFormat
    */
   /*-->
   public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-   
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
   }
   -->*/
   
+  
   //---------------------------------------------------------------------------
   // members
   //
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   /*-->
   protected Object[]  _args       = null;
+  -->*/
+  
+  /**
+   * The wrapped, nested of next exception.
+   */
+  /*-->
   protected Exception _next       = null;
+  -->*/
+
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
+  /*-->
   protected boolean   _isWrapper  = false;
   -->*/
 }
diff --git a/susebox/java/lang/ExceptionMessageFormatter.class b/susebox/java/lang/ExceptionMessageFormatter.class
new file mode 100644
index 0000000..c86c39a
Binary files /dev/null and b/susebox/java/lang/ExceptionMessageFormatter.class differ
diff --git a/susebox/java/lang/ExceptionMessageFormatter.java b/susebox/java/lang/ExceptionMessageFormatter.java
new file mode 100644
index 0000000..bc65980
--- /dev/null
+++ b/susebox/java/lang/ExceptionMessageFormatter.java
@@ -0,0 +1,137 @@
+/*
+ * ExceptionMessageFormatter.java: formatting an exception message
+ *
+ * Copyright (C) 2001 Heiko Blau
+ *
+ * This file belongs to the Susebox Java Core Library (Susebox JCL).
+ * The Susebox JCL is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along
+ * with the Susebox JCL. If not, write to the
+ *
+ *   Free Software Foundation, Inc.
+ *   59 Temple Place, Suite 330,
+ *   Boston, MA 02111-1307
+ *   USA
+ *
+ * or check the Internet: http://www.fsf.org
+ *
+ * Contact:
+ *   email: heiko@susebox.de
+ */
+
+package de.susebox.java.lang;
+
+//------------------------------------------------------------------------------
+// Imports
+//
+import java.text.MessageFormat;
+import de.susebox.java.lang.ExceptionList;
+
+
+//------------------------------------------------------------------------------
+// Class ExceptionMessageFormatter
+//
+
+/**<p>
+ * This class is used by the implementations of the {@link ExceptionList} interface.
+ * Its method {@link #getMessage} formats the message that should be returned by 
+ * the {@link java.lang.Throwable#getMessage} overridden by implementations of the 
+ * {@link ExceptionList} interface.
+ *</p>
+ *
+ * @see     ExceptionList
+ * @see     java.lang.Throwable
+ * @see     java.text.MessageFormat
+ * @author 	Heiko Blau
+ */
+public final class ExceptionMessageFormatter {
+  
+  /**
+   * Message indentation for nested exceptions.
+   */
+  public static final String MSG_IDENTATION = "    ";
+  
+  /**
+   * This method should be called by all implementations of the {@link ExceptionList}
+   * interface in their {@link java.lang.Throwable#getMessage} implementation. It
+   * ensures that the formatting of exception lists, nested or wrapped exceptions 
+   * is done in a consistent way.
+   * <br>
+   * The method returns an exception message assembled in this way:
+   * <br><ol><li>
+   *  If the calling exception is a wrapper exception (see {@link ExceptionList#isWrapperException}),
+   *  it delegates the call to the wrapped exception (<code>wrappedEx.getMessage()</code>).
+   * </li><li>
+   *  If there is a nested exception (the calling exception has a message of its own),
+   *  the returned message starts with the string returned by the {@link java.lang.Object#toString}
+   *  method, followed and separated by a end-of-line sequence by the formatted message
+   *  of the calling exception.
+   * </li><li>
+   *  If the calling exception has only a message without parameters, this message
+   *  is either appended to the string produced by processing a nested exception or
+   *  is taken as the entire return value if there is no nested or subsequent exception
+   *  present.
+   * </li><li>
+   *  If the calling exception provides parameters along with a format string (the
+   *  return value of <code>super.getMessage</code> is interpreted as a format string),
+   *  a formatted message produced by {@link java.text.MessageFormat#format} is either
+   *  appended to the string produced by processing a nested exception or is taken as
+   *  the entire return value if there is no nested or subsequent exception present.
+   * </li><ol>
+   *
+   * @param   ex  the calling exception
+   * @return  the formatted exception message
+   * @see     java.text.MessageFormat
+   * @see     ExceptionList
+   */
+  public static final String getMessage(ExceptionList ex) {
+    // wrapped exceptions return theri own message
+    if (ex.isWrapperException()) {
+      return ex.nextException().getMessage();
+    }
+    
+    // prepare the formatting
+    StringBuffer  msg  = new StringBuffer();
+    String        fmt  = ex.getFormat();
+    String        nl   = System.getProperty("line.separator");
+    Exception     next = ex.nextException();
+    
+    // message of the nested or next exception first
+    if (next != null) {
+      msg.append(_eolSequence);
+      msg.append(MSG_IDENTATION);
+      msg.append(next.toString());
+      if (fmt != null) {
+        msg.append(_eolSequence);
+        msg.append(MSG_IDENTATION);
+      }
+    }
+
+    // and now our own message
+    if (fmt != null) {
+      Object[] args = ex.getArguments();
+      
+      if (args == null) {
+        msg.append(fmt);
+      } else {
+        msg.append(MessageFormat.format(fmt, args));
+      }
+    }
+    return msg.toString();
+  }
+
+  
+  //---------------------------------------------------------------------------
+  // members
+  //
+  private static final String _eolSequence = System.getProperty("line.separator");
+}
diff --git a/susebox/java/lang/ExtIndexOutOfBoundsException.class b/susebox/java/lang/ExtIndexOutOfBoundsException.class
new file mode 100644
index 0000000..e1c2960
Binary files /dev/null and b/susebox/java/lang/ExtIndexOutOfBoundsException.class differ
diff --git a/susebox/java/lang/ExtIndexOutOfBoundsException.java b/susebox/java/lang/ExtIndexOutOfBoundsException.java
index 927daee..5029d6a 100644
--- a/susebox/java/lang/ExtIndexOutOfBoundsException.java
+++ b/susebox/java/lang/ExtIndexOutOfBoundsException.java
@@ -34,7 +34,9 @@ package de.susebox.java.lang;
 // Imports
 //
 import java.lang.IndexOutOfBoundsException;
-import java.text.MessageFormat;
+
+import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 
 
 //------------------------------------------------------------------------------
@@ -57,10 +59,8 @@ public class ExtIndexOutOfBoundsException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
    */
@@ -79,6 +79,28 @@ public class ExtIndexOutOfBoundsException
     return _isWrapper;
   }
   
+  /**
+   * Getting the format string of a exception message. This can also be the
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }  
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
   
   //---------------------------------------------------------------------------
   // constructors
@@ -152,10 +174,16 @@ public class ExtIndexOutOfBoundsException
    * @param fmt   exception message
    * @param args  arguments for the given format string
    */
-  public ExtIndexOutOfBoundsException(Exception ex, String msg, Object[] args) {
-    super(msg);
-    _next      = ex;
-    _isWrapper = true;
+  public ExtIndexOutOfBoundsException(Exception ex, String fmt, Object[] args) {
+    super(fmt);
+   
+    if (ex != null && fmt == null) {
+      _isWrapper = true;
+    } else {
+      _isWrapper = false;
+    }
+    _next = ex;
+    _args = args;
   }
   
   
@@ -164,37 +192,36 @@ public class ExtIndexOutOfBoundsException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.Throwable#getMessage} method. It
+   * delegates the call to the central {@link ExceptionMessageFormatter#getMessage}
+   * method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
+   * @see     ExceptionMessageFormatter
    */
   public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-      
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
   }
   
-  
+
   //---------------------------------------------------------------------------
   // members
   //
+
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/java/lang/ExtRuntimeException.class b/susebox/java/lang/ExtRuntimeException.class
new file mode 100644
index 0000000..600e99d
Binary files /dev/null and b/susebox/java/lang/ExtRuntimeException.class differ
diff --git a/susebox/java/lang/ExtRuntimeException.java b/susebox/java/lang/ExtRuntimeException.java
index 03ee589..7d650d9 100644
--- a/susebox/java/lang/ExtRuntimeException.java
+++ b/susebox/java/lang/ExtRuntimeException.java
@@ -42,7 +42,8 @@ import java.text.MessageFormat;
 //
 
 /**
- * Implementation of the ExceptionList interface for the JDK RuntimeException.
+ * Implementation of the {@link ExceptionList} interface for the well-knwon JDK 
+ * {@link java.lang.RuntimeException}.
  *
  * @version	1.00, 2001/06/26
  * @author 	Heiko Blau
@@ -56,10 +57,8 @@ public class ExtRuntimeException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
    */
@@ -78,6 +77,28 @@ public class ExtRuntimeException
     return _isWrapper;
   }
   
+  /**
+   * Getting the format string of a exception message. This can also be the 
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
   
   //---------------------------------------------------------------------------
   // constructors
@@ -151,10 +172,16 @@ public class ExtRuntimeException
    * @param fmt   exception message
    * @param args  arguments for the given format string
    */
-  public ExtRuntimeException(Exception ex, String msg, Object[] args) {
-    super(msg);
-    _next      = ex;
-    _isWrapper = true;
+  public ExtRuntimeException(Exception ex, String fmt, Object[] args) {
+    super(fmt);
+   
+    if (ex != null && fmt == null) {
+      _isWrapper = true;
+    } else {
+      _isWrapper = false;
+    }
+    _next = ex;
+    _args = args;
   }
   
   
@@ -163,37 +190,35 @@ public class ExtRuntimeException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.Throwable#getMessage} method. It
+   * delegates the call to the central {@link ExceptionMessageFormatter#getMessage}
+   * method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
+   * @see     ExceptionMessageFormatter
    */
   public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-      
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
   }
   
-  
   //---------------------------------------------------------------------------
   // members
   //
+  
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/java/util/AbstractTokenizer.java b/susebox/java/util/AbstractTokenizer.java
index 9de7264..8a0e829 100644
--- a/susebox/java/util/AbstractTokenizer.java
+++ b/susebox/java/util/AbstractTokenizer.java
@@ -1268,6 +1268,25 @@ __MAIN_LOOP__:
     return new String(_inputBuffer, start - _rangeStart, len);
   }
   
+
+  /**
+   * Retrieve text from the currently available range. The start and length
+   * parameters must be inside {@link #getRangeStart} and
+   * <CODE>getRangeStart + {@link #currentlyAvailable}</CODE>. 
+   *<br>
+   * In contrast to the {@link #getText} method this one does not check for 
+   * correct parameters. Two situations may arise:<br> 
+   *   an {@link java.util.IndexOutOfBoundsException may occure<br>
+   *   uninitialized data may be retrieved
+   *
+   * @param   start   position where the text begins
+   * @param   len     length of the text
+   * @return  the text beginning at the given position ith the given length
+   */
+  public String getTextUnchecked(int start, int len) {
+    return new String(_inputBuffer, start - _rangeStart, len);
+  }
+  
   /**
    * Get a single character from the current text range.
    *
@@ -1516,6 +1535,40 @@ __MAIN_LOOP__:
     return prop;
   }
 
+
+  /**
+   * This method checks if the character sequence starting at a given position
+   * with a given lenght is a keyword. If so, it returns the keyword description
+   * as {@link TokenizerProperty} object.
+   *<br>
+   * If the method needs to build a string from the character sequence it may
+   * use {@link #getText} or {@link #getTextUnchecked} to retrieve it.
+   *<br>
+   * This method is should be overwritten by derived classes having their own
+   * keyword handling.
+   *
+   * @param   startingAtPos   check at this position
+   * @param   length          the candidate has this number of characters
+   * @return  {@link TokenizerProperty} describing the keyword or <code>null</code>
+   */
+  protected TokenizerProperty isKeyword(int startingAtPos, int length) {
+    TokenizerProperty prop = null;
+    
+    // test on keyword
+    if (_keywords[0] != null || _keywords[1] != null) {
+      String            keyword = new String(_inputBuffer, startingAtPos - _rangeStart, length);
+      
+      if (_keywords[0] != null) {
+        prop = (TokenizerProperty)_keywords[0].get(keyword);
+      }
+      if (prop == null && _keywords[1] != null) {
+        keyword = keyword.toUpperCase();
+        prop    = (TokenizerProperty)_keywords[1].get(keyword);
+      }
+    }
+    return prop;
+  }
+  
   
   //---------------------------------------------------------------------------
   // Implementation
@@ -1704,29 +1757,15 @@ __MAIN_LOOP__:
     }
     
     // test on keyword
-    if (_keywords[0] != null || _keywords[1] != null) {
-      TokenizerProperty prop    = null;
-      String            keyword = new String(_inputBuffer, _currentReadPos, len);
-      
-      if (_keywords[0] != null) {
-        prop = (TokenizerProperty)_keywords[0].get(keyword);
-      }
-      if (prop == null && _keywords[1] != null) {
-        keyword = keyword.toUpperCase();
-        prop    = (TokenizerProperty)_keywords[1].get(keyword);
-      }
-      if (prop != null) {
-        token.setType(Token.KEYWORD); 
-        token.setLength(keyword.length());
-        token.setCompanion(prop.getCompanion());
-      } else {
-        token.setType(Token.NORMAL);
-        token.setLength(len);
-      }
+    TokenizerProperty prop = isKeyword(_currentReadPos + _rangeStart, len);
+    
+    if (prop != null) {
+      token.setType(Token.KEYWORD); 
+      token.setCompanion(prop.getCompanion());
     } else {
       token.setType(Token.NORMAL);
-      token.setLength(len);
     }
+    token.setLength(len);
     return true;
   }
   
diff --git a/susebox/java/util/Token.java b/susebox/java/util/Token.java
index cc1ffad..0471373 100644
--- a/susebox/java/util/Token.java
+++ b/susebox/java/util/Token.java
@@ -54,23 +54,23 @@ public class Token {
   /**
    * The token is nothing special (no keyword, no whitespace, etc.).
    */  
-  public static final int NORMAL = 0;
+  public static final byte NORMAL = 0;
 
   /**
    * The token is a keyword registered with the used {@link Tokenizer}.
    */  
-  public static final int KEYWORD = 1;
+  public static final byte KEYWORD = 1;
 
   /**
    * The token is one of the quoted strings known to the {@link Tokenizer}. In Java
    * this would be for instance a "String" or a 'c' (haracter).
    */  
-  public static final int STRING = 2;
+  public static final byte STRING = 2;
   
   /**
    * If a {@link Tokenizer} recognizes numbers, this token is one.
    */  
-  public static final int NUMBER = 3;
+  public static final byte NUMBER = 3;
   
   /**
    * Special sequences are characters or character combinations that have a certain
@@ -79,14 +79,14 @@ public class Token {
    * A companion might have been associated with a special sequence. It probably
    * contains information important to the user of the <CODE>Token</CODE>.
    */  
-  public static final int SPECIAL_SEQUENCE = 4;
+  public static final byte SPECIAL_SEQUENCE = 4;
   
   /** 
    * Separators are otherwise not remarkable characters. An opening parenthesis 
    * might be nessecary for a syntactically correct text, but without any special 
    * meaning to the compiler, interpreter etc. after it has been detected.
    */  
-  public static final int SEPARATOR = 5;
+  public static final byte SEPARATOR = 5;
   
   /** 
    * Whitespaces are portions of the text, that contain one or more characters 
@@ -94,31 +94,31 @@ public class Token {
    * whitespaces is equally represented by one single whitespace character. That 
    * is the difference to separators.
    */  
-  public static final int WHITESPACE = 6;
+  public static final byte WHITESPACE = 6;
 
   /**
    * Although a line comment is - in most cases - actually a whitespace sequence, it
    * is often nessecary to handle it separately. Syntax hilighting is a thing that
    * needs to know a line comment.
    */  
-  public static final int LINE_COMMENT = 7;
+  public static final byte LINE_COMMENT = 7;
 
   /**
    * Block comments are also a special form of a whitespace sequence. See 
    * {@link #LINE_COMMENT} for details.
    */  
-  public static final int BLOCK_COMMENT = 8;
+  public static final byte BLOCK_COMMENT = 8;
 
   /**
    * A token of the type <CODE>EOF</CODE> is used to indicate an end-of-line condition
    * on the input stream of the tokenizer.
    */  
-  public static final int EOF = -1;
+  public static final byte EOF = -1;
   
   /**
    * This is for the leftovers of the lexical analysis of a text.
    */  
-  public static final int UNKNOWN = -2;
+  public static final byte UNKNOWN = -2;
     
 
   //---------------------------------------------------------------------------
diff --git a/susebox/java/util/Tokenizer.java b/susebox/java/util/Tokenizer.java
index b74333b..39b3ae0 100644
--- a/susebox/java/util/Tokenizer.java
+++ b/susebox/java/util/Tokenizer.java
@@ -196,7 +196,7 @@ public interface Tokenizer
    * Without this flag, comparison is done like in Java or C/C++. When the flag 
    * is set, the tokenizer compares tokens like in HTML or PL/SQL.
    */
-  public static final int F_NO_CASE               = 0x0001;
+  public static final short F_NO_CASE               = 0x0001;
 
   /**
    * In case that the <CODE>F_NO_CASE</CODE> flag is set, this flag is used to
@@ -204,7 +204,7 @@ public interface Tokenizer
    * The combination between <CODE>F_NO_CASE</CODE> and <CODE>F_KEYWORDS_CASE</CODE>
    * means, that keywords are case-sensitive but everything else is not.
    */
-  public static final int F_KEYWORDS_CASE         = 0x0002;
+  public static final short F_KEYWORDS_CASE         = 0x0002;
   
   /**
    * In case that the <CODE>F_NO_CASE</CODE> flag is not set, this flag is used 
@@ -212,44 +212,44 @@ public interface Tokenizer
    * The flag <CODE>F_KEYWORDS_NO_CASE</CODE> means, that keywords are not 
    * case-sensitive but everything else is.
    */
-  public static final int F_KEYWORDS_NO_CASE      = 0x0004;
+  public static final short F_KEYWORDS_NO_CASE      = 0x0004;
   
   /**
    * In many cases, parsers are not interested in whitespaces. If You are, use
    * this flag to force the tokenizer to return whitespace sequences as a token.
    */
-  public static final int F_RETURN_WHITESPACES    = 0x0008;
+  public static final short F_RETURN_WHITESPACES    = 0x0008;
   
   /**
    * For perfomance and memory reasons, this flag is used to avoid copy operations
    * for every token. The token image itself is not returned in a {@link Token}
    * instance, only its position and length in the input stream.
    */
-  public static final int F_TOKEN_POS_ONLY        = 0x0010;
+  public static final short F_TOKEN_POS_ONLY        = 0x0010;
 
   /**
    * Set this flag to let the tokenizer buffer all data. Normally, a tokenizer
    * keeps only a certain amount of periodically changing data in its internal 
    * buffer.
    */
-  public static final int F_KEEP_DATA             = 0x0020;
+  public static final short F_KEEP_DATA             = 0x0020;
 
   /**
    * Tells the tokenizer to count lines and columns. The tokenizer may use
    * System.getProperty("line.separator") to obtain the end-of-line sequence.
    */
-  public static final int F_COUNT_LINES           = 0x0040;
+  public static final short F_COUNT_LINES           = 0x0040;
 
   /**
    * Nested block comments are normally not allowed. This flag changes the 
    * default behaviour
    */
-  public static final int F_ALLOW_NESTED_COMMENTS = 0x0080;
+  public static final short F_ALLOW_NESTED_COMMENTS = 0x0080;
   
   /**
    * With this flag, the tokenizer tries to identify numbers.
    */
-  public static final int F_PARSE_NUMBERS         = 0x0100;
+  public static final short F_PARSE_NUMBERS         = 0x0100;
 
 
   //---------------------------------------------------------------------------
diff --git a/susebox/java/util/TokenizerException.java b/susebox/java/util/TokenizerException.java
index 118710a..dbf87d3 100644
--- a/susebox/java/util/TokenizerException.java
+++ b/susebox/java/util/TokenizerException.java
@@ -33,9 +33,8 @@ package de.susebox.java.util;
 //------------------------------------------------------------------------------
 // Imports
 //
-
-import java.text.MessageFormat;
 import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 
 
 //------------------------------------------------------------------------------
@@ -63,13 +62,11 @@ public class TokenizerException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link de.susebox.java.lang.ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
-   */  
+   */
   public Exception nextException() {
 		return _next;
 	}
@@ -85,6 +82,28 @@ public class TokenizerException
 		return _isWrapper;
 	}
 
+  /**
+   * Getting the format string of a exception message. This can also be the
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }  
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
   
   //---------------------------------------------------------------------------
   // constructors
@@ -158,14 +177,15 @@ public class TokenizerException
    * @param args  arguments for the given format string
    */  
 	public TokenizerException(Exception ex, String fmt, Object[] args) {
-		super(fmt);
-    
+    super(fmt);
+   
     if (ex != null && fmt == null) {
       _isWrapper = true;
     } else {
       _isWrapper = false;
     }
     _next = ex;
+    _args = args;
 	}
 
 
@@ -174,38 +194,35 @@ public class TokenizerException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to 
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped 
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.langThrowable#getMessage} method. It
+   * delegates the call to the central 
+   * {@link de.susebox.java.lang.ExceptionMessageFormatter#getMessage} method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
-   */  
+   * @see     de.susebox.java.lang.ExceptionMessageFormatter
+   */
 	public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
 	}
 
-  
-  
   //---------------------------------------------------------------------------
   // members
   //
+
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/jtopas/#KeywordHandler.java# b/susebox/jtopas/#KeywordHandler.java#
new file mode 100644
index 0000000..b8941ad
--- /dev/null
+++ b/susebox/jtopas/#KeywordHandler.java#
@@ -0,0 +1,77 @@
+/*
+ * KeywordHandler.java: Pluggin for the PluginTokenizer.
+ *
+ * Copyright (C) 2002 Heiko Blau
+ *
+ * This file belongs to the JTopas Library.
+ * JTopas is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU Lesser General Public License as published by the 
+ * Free Software Foundation; either version 2.1 of the License, or (at your 
+ * option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along
+ * with JTopas. If not, write to the
+ *
+ *   Free Software Foundation, Inc.
+ *   59 Temple Place, Suite 330, 
+ *   Boston, MA 02111-1307 
+ *   USA
+ *
+ * or check the Internet: http://www.fsf.org
+ *
+ * Contact:
+ *   email: heiko@susebox.de 
+ */
+
+package de.susebox.jtopas;
+
+//-----------------------------------------------------------------------------
+// Imports
+//
+import de.susebox.java.util.TokenizerProperty;
+import de.susebox.java.util.TokenizerException;
+
+
+//-----------------------------------------------------------------------------
+// Interface KeywordHandler
+//
+
+/**<p>
+ * This interface must be implemented by classes that should be used as a 
+ * keyword handler plugin in the {@link PluginTokenizer}.
+ *</p>
+ *
+ * @see     de.susebox.java.util.Tokenizer
+ * @see     de.susebox.java.util.AbstractTokenizer
+ * @author  Heiko Blau
+ */
+public interface KeywordHandler extends Plugin {
+  
+  /**
+   * This method checks if the character sequence starting at a given position
+   * with a given length is a keyword. If so, it returns the keyword description
+   * as {@link TokenizerProperty} object.
+   * If the method needs to build a string from the character sequence it may
+   * use {@link #getText} or {@link #getTextUnchecked} to retrieve it.
+   *
+   * @param   startingAtPos   check at this position
+   * @param   length          number of characters in the token to be tested
+   * @return  {@link TokenizerProperty} describing the keyword or <code>null</code>
+   */
+  public TokenizerProperty isKeyword(int startingAtPos, int length); 
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/susebox/jtopas/InputStreamSource.java b/susebox/jtopas/InputStreamSource.java
index bcc780c..a2aae03 100644
--- a/susebox/jtopas/InputStreamSource.java
+++ b/susebox/jtopas/InputStreamSource.java
@@ -70,8 +70,8 @@ public class InputStreamSource implements TokenizerSource {
    * A basic method to supply data to a {@link de.susebox.java.util.Tokenizer}.
    *
    * @param cbuf      buffer to receive data
-   * @param offset    position from where the data should be inserted in <CODE>cbuf</CODE>
-   * @param maxChars  maximum number of characters to be read into <CODE>cbuf</CODE>
+   * @param offset    position from where the data should be inserted in <code>cbuf</code>
+   * @param maxChars  maximum number of characters to be read into <code>cbuf</code>
    * @return actually read characters or -1 on an end-of-file condition
    * @throws Exception anything that could happen during read, most likely {@link java.io.IOException}
    */
@@ -107,7 +107,7 @@ public class InputStreamSource implements TokenizerSource {
 
   /**
    * Constructor that takes a instantiated {@link java.io.Reader}. If 
-   * <CODE>null</CODE> is given then standard input is used (see {@link java.lang.System#in}).
+   * <code>null</code> is given then standard input is used (see {@link java.lang.System#in}).
    *
    * @param Reader   input stream to be used for reading
    * @see   java.io.Reader
@@ -119,9 +119,9 @@ public class InputStreamSource implements TokenizerSource {
   /**
    * Constructor that takes a instantiated {@link java.io.Reader} and the
    * tokenizer control flags.
-   * If <CODE>null</CODE> is given for the stream then standard input is used 
+   * If <code>null</code>> is given for the stream then standard input is used 
    * (see {@link java.lang.System#in}).
-   * For the tokenizer control flags use a combination of the <CODE>F_...</CODE>
+   * For the tokenizer control flags use a combination of the <code>F_...</code>
    * constants from the {@link Tokenizer} for this parameter.
    *
    * @param reader   input stream to be used for reading
@@ -166,5 +166,9 @@ public class InputStreamSource implements TokenizerSource {
   //---------------------------------------------------------------------------
   // Members
   //
+  
+  /**
+   * The {@link java.io.Reader} instance that does the actual reading.
+   */
   protected Reader _reader = null;
 }
diff --git a/susebox/jtopas/KeywordHandler.class b/susebox/jtopas/KeywordHandler.class
new file mode 100644
index 0000000..3db489e
Binary files /dev/null and b/susebox/jtopas/KeywordHandler.class differ
diff --git a/susebox/jtopas/KeywordHandler.java b/susebox/jtopas/KeywordHandler.java
new file mode 100644
index 0000000..5af4376
--- /dev/null
+++ b/susebox/jtopas/KeywordHandler.java
@@ -0,0 +1,67 @@
+/*
+ * KeywordHandler.java: Pluggin for the PluginTokenizer.
+ *
+ * Copyright (C) 2002 Heiko Blau
+ *
+ * This file belongs to the JTopas Library.
+ * JTopas is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU Lesser General Public License as published by the 
+ * Free Software Foundation; either version 2.1 of the License, or (at your 
+ * option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License along
+ * with JTopas. If not, write to the
+ *
+ *   Free Software Foundation, Inc.
+ *   59 Temple Place, Suite 330, 
+ *   Boston, MA 02111-1307 
+ *   USA
+ *
+ * or check the Internet: http://www.fsf.org
+ *
+ * Contact:
+ *   email: heiko@susebox.de 
+ */
+
+package de.susebox.jtopas;
+
+//-----------------------------------------------------------------------------
+// Imports
+//
+import de.susebox.java.util.TokenizerProperty;
+import de.susebox.java.util.TokenizerException;
+
+
+//-----------------------------------------------------------------------------
+// Interface KeywordHandler
+//
+
+/**<p>
+ * This interface must be implemented by classes that should be used as a 
+ * keyword handler plugin in the {@link PluginTokenizer}.
+ *</p>
+ *
+ * @see     de.susebox.java.util.Tokenizer
+ * @see     de.susebox.java.util.AbstractTokenizer
+ * @author  Heiko Blau
+ */
+public interface KeywordHandler extends Plugin {
+  
+  /**
+   * This method checks if the character sequence starting at a given position
+   * with a given length is a keyword. If so, it returns the keyword description
+   * as {@link TokenizerProperty} object.
+   * If the method needs to build a string from the character sequence it may
+   * use {@link #getText} or {@link #getTextUnchecked} to retrieve it.
+   *
+   * @param   startingAtPos   check at this position
+   * @param   length          number of characters in the token to be tested
+   * @return  {@link TokenizerProperty} describing the keyword or <code>null</code>
+   */
+  public TokenizerProperty isKeyword(int startingAtPos, int length); 
+}
diff --git a/susebox/jtopas/Plugin.java b/susebox/jtopas/Plugin.java
index d8e4899..61edb1d 100644
--- a/susebox/jtopas/Plugin.java
+++ b/susebox/jtopas/Plugin.java
@@ -37,6 +37,8 @@ package de.susebox.jtopas;
 
 /**<p>
  * This is the base interface for all handler pluggins in the {@link PluginTokenizer}.
+ * Since generally plugins need to know their parent <code>Tokenizer</code>, this
+ * interface is provided to pass that instance to the plugin.
  *</p>
  *
  * @see     de.susebox.java.util.Tokenizer
diff --git a/susebox/jtopas/PluginTokenizer.java b/susebox/jtopas/PluginTokenizer.java
index 7622f08..a38f6b8 100644
--- a/susebox/jtopas/PluginTokenizer.java
+++ b/susebox/jtopas/PluginTokenizer.java
@@ -163,6 +163,33 @@ public class PluginTokenizer extends AbstractTokenizer {
   }
   
   
+  /**
+   * Setting a new {@link KeywordHandler} or removing any previously installed
+   * one. If <code>null</code> is passed (installed handler removed), the 
+   * tokenizer will fall back to the base implementation.
+   *
+   * @param handler   the (new) {@link KeywordHandler} to use or null to remove it
+   */
+  public void setKeywordHandler(KeywordHandler handler) {
+    if ((_keywordHandler = handler) != null) {
+      _keywordHandler.setTokenizer(this);
+    }
+  }
+  
+  /**
+   * Retrieving the current {@link KeywordHandler}. The method may return
+   * <code>null</code> if there isn't any handler installed. That does not
+   * mean, that keywords are not dealt with. Keyword detection is done by the 
+   * base method of {@link de.susebox.java.util.AbstractTokenizer} in that case.
+   *
+   * @return  the currently active whitespace keyword or null, if the base
+   *          implementation is working
+   */
+  public KeywordHandler getKeywordHandler() {
+    return _keywordHandler;
+  }
+  
+  
   /**
    * Setting a new {@link WhitespaceHandler} or removing any previously installed
    * <code>WhitespaceHandler</code>. If <code>null</code> is passed, the tokenizer
@@ -248,6 +275,26 @@ public class PluginTokenizer extends AbstractTokenizer {
   // Overridden methods of AbstractTokenizer
   //
   
+  /**
+   * This method checks if the character sequence starting at a given position
+   * with a given lenght is a keyword. If so, it returns the keyword description
+   * as {@link TokenizerProperty} object.
+   * If the method needs to build a string from the character sequence it may
+   * use {@link #getText} or {@link #getTextUnchecked} to retrieve it.
+   *
+   * @param   startingAtPos check at this position
+   * @param   length        the candidate has this number of characters
+   * @return  {@link TokenizerProperty} describing the keyword or <code>null</code>
+   */
+  protected TokenizerProperty isKeyword(int startingAtPos, int length) {
+    if (_keywordHandler != null) {
+      return _keywordHandler.isKeyword(startingAtPos, length);
+    } else {
+      return super.isKeyword(startingAtPos, length);
+    }
+  }
+    
+  
   /**
    * This method checks if the character is a whitespace. It will use an installed
    * {@link WhitespaceHandler} or switch back to the base implementation.
@@ -354,4 +401,5 @@ public class PluginTokenizer extends AbstractTokenizer {
   private WhitespaceHandler _whitespaceHandler = null;
   private SeparatorHandler  _separatorHandler  = null;
   private SequenceHandler   _sequenceHandler   = null;
+  private KeywordHandler    _keywordHandler    = null;
 }
