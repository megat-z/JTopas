diff --git a/susebox/java/io/ExtIOException.java b/susebox/java/io/ExtIOException.java
index 877f9e5..4c71ed0 100644
--- a/susebox/java/io/ExtIOException.java
+++ b/susebox/java/io/ExtIOException.java
@@ -33,10 +33,10 @@ package de.susebox.java.io;
 //------------------------------------------------------------------------------
 // Imports
 //
-import java.text.MessageFormat;
 import java.io.IOException;
 
 import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 
 
 //------------------------------------------------------------------------------
@@ -58,13 +58,11 @@ public class ExtIOException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link de.susebox.java.lang.ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
-   */  
+   */
   public Exception nextException() {
 		return _next;
 	}
@@ -80,6 +78,28 @@ public class ExtIOException
 		return _isWrapper;
 	}
 
+  /**
+   * Getting the format string of a exception message. This can also be the
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }  
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
 
   //---------------------------------------------------------------------------
   // constructors
@@ -153,10 +173,16 @@ public class ExtIOException
    * @param fmt   exception message
    * @param args  arguments for the given format string
    */  
-	public ExtIOException(Exception ex, String msg, Object[] args) {
-		super(msg);
-		_next      = ex;
-		_isWrapper = true;
+	public ExtIOException(Exception ex, String fmt, Object[] args) {
+    super(fmt);
+   
+    if (ex != null && fmt == null) {
+      _isWrapper = true;
+    } else {
+      _isWrapper = false;
+    }
+    _next = ex;
+    _args = args;
 	}
 
 
@@ -165,37 +191,36 @@ public class ExtIOException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to 
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped 
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.langThrowable#getMessage} method. It
+   * delegates the call to the central 
+   * {@link de.susebox.java.lang.ExceptionMessageFormatter#getMessage} method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
-   */  
+   * @see     de.susebox.java.lang.ExceptionMessageFormatter
+   */
 	public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
 	}
 
   
   //---------------------------------------------------------------------------
   // members
   //
+
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/java/lang/ExceptionList.java b/susebox/java/lang/ExceptionList.java
index b0c3b24..2c90b00 100644
--- a/susebox/java/lang/ExceptionList.java
+++ b/susebox/java/lang/ExceptionList.java
@@ -35,9 +35,8 @@ package de.susebox.java.lang;
 //
 
 /*-->
-import java.text.MessageFormat;
- 
 import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 -->*/
 
 
@@ -69,11 +68,29 @@ import de.susebox.java.lang.ExceptionList;
  * @author 	Heiko Blau
  */
 public interface ExceptionList {
+  
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
+   * Method to traverse the exception list. By convention, <code>nextException</code>>
    * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
+   * the following meaning:
+   *<br>
    * this happened because nextException happened because nextException happened...
+   *<br>
+   * The next exception has usually one of the following meaning:
+   *<br><ul><li>
+   *  It is the "real" exception. An interface implementation might be allowed to 
+   *  throw only <code>IOException</code>, but actually has to pass on a 
+   *  <code>SQLException</code>. That ould be done by wrapping the <code>SQLException</code>
+   *  into the <code>IOException</code>.
+   *</li><li>
+   *  The next exception is "deeper" cause of this one (often called a nested
+   *  exception). A file couldn't be read in the first place and therefore not be 
+   *  attached to a mail. Both this exception and the one nested inside have their
+   *  own message.
+   *</li></li>
+   *  There are more than one basic exception to be propagated. A simple parser 
+   *  might return all syntax errors in one exception list.
+   *</li><ul>
    *
    * @return the "earlier" exception
    */
@@ -99,11 +116,52 @@ public interface ExceptionList {
   }
   -->*/
   
+  /**
+   * Getting the format string of a exception message. This can also be the 
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat();
+  /*-->
+  {
+    return super.getMessage();
+  }
+  -->*/
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments();
+  /*-->
+  {
+    return _args;
+  }
+  -->*/
+  
   
   //---------------------------------------------------------------------------
   // implementation code templates
   //
   
+  /**
+   * This constructor takes a simple message string like ordinary Java exceptions.
+   * This is the most convenient form to construct an <code>ExceptionList</code>
+   * exception.
+   *
+   * @param msg   exception message
+   */
+  /*-->
+  public <<WHICH>>Exception(String msg) {
+    this(null, msg, null);
+  }
+  -->*/
+  
   /**
    * This constructor should be used for wrapping another exception. While reading
    * data an IOException may occur, but a certain interface requires a
@@ -158,7 +216,7 @@ public interface ExceptionList {
    *    new MyException(fmt, args).getMessage();
    *<CODE>
    *
-   * @param fmt   exception message
+   * @param fmt   exception message format
    * @param args  arguments for the given format string
    */
   /*-->
@@ -188,44 +246,54 @@ public interface ExceptionList {
       _isWrapper = false;
     }
     _next = ex;
+    _args = args;
   }
   -->
    
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to
+   * Implementation of the standard {@link java.lang.Throwable#getMessage} method to
    * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * exceptions.<br>
+   * If this is a wrapper exception then the <code>getMessage</code> of the wrapped
+   * exception is returned.<br>
+   * If this is not a wrapper exception: if no arguments were given in the 
+   * constructor then the format parameter is taken as the formatted message itself. 
+   * Otherwise it is treated like the patter for the {@link java.text.MessageFormat#format}
+   * method.
    *
    * @return  the formatted exception message
    * @see     java.text.MessageFormat
    */
   /*-->
   public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-   
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
   }
   -->*/
   
+  
   //---------------------------------------------------------------------------
   // members
   //
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   /*-->
   protected Object[]  _args       = null;
+  -->*/
+  
+  /**
+   * The wrapped, nested of next exception.
+   */
+  /*-->
   protected Exception _next       = null;
+  -->*/
+
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
+  /*-->
   protected boolean   _isWrapper  = false;
   -->*/
 }
diff --git a/susebox/java/lang/ExtIndexOutOfBoundsException.java b/susebox/java/lang/ExtIndexOutOfBoundsException.java
index 927daee..5029d6a 100644
--- a/susebox/java/lang/ExtIndexOutOfBoundsException.java
+++ b/susebox/java/lang/ExtIndexOutOfBoundsException.java
@@ -34,7 +34,9 @@ package de.susebox.java.lang;
 // Imports
 //
 import java.lang.IndexOutOfBoundsException;
-import java.text.MessageFormat;
+
+import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 
 
 //------------------------------------------------------------------------------
@@ -57,10 +59,8 @@ public class ExtIndexOutOfBoundsException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
    */
@@ -79,6 +79,28 @@ public class ExtIndexOutOfBoundsException
     return _isWrapper;
   }
   
+  /**
+   * Getting the format string of a exception message. This can also be the
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }  
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
   
   //---------------------------------------------------------------------------
   // constructors
@@ -152,10 +174,16 @@ public class ExtIndexOutOfBoundsException
    * @param fmt   exception message
    * @param args  arguments for the given format string
    */
-  public ExtIndexOutOfBoundsException(Exception ex, String msg, Object[] args) {
-    super(msg);
-    _next      = ex;
-    _isWrapper = true;
+  public ExtIndexOutOfBoundsException(Exception ex, String fmt, Object[] args) {
+    super(fmt);
+   
+    if (ex != null && fmt == null) {
+      _isWrapper = true;
+    } else {
+      _isWrapper = false;
+    }
+    _next = ex;
+    _args = args;
   }
   
   
@@ -164,37 +192,36 @@ public class ExtIndexOutOfBoundsException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.Throwable#getMessage} method. It
+   * delegates the call to the central {@link ExceptionMessageFormatter#getMessage}
+   * method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
+   * @see     ExceptionMessageFormatter
    */
   public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-      
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
   }
   
-  
+
   //---------------------------------------------------------------------------
   // members
   //
+
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/java/lang/ExtRuntimeException.java b/susebox/java/lang/ExtRuntimeException.java
index 03ee589..7d650d9 100644
--- a/susebox/java/lang/ExtRuntimeException.java
+++ b/susebox/java/lang/ExtRuntimeException.java
@@ -42,7 +42,8 @@ import java.text.MessageFormat;
 //
 
 /**
- * Implementation of the ExceptionList interface for the JDK RuntimeException.
+ * Implementation of the {@link ExceptionList} interface for the well-knwon JDK 
+ * {@link java.lang.RuntimeException}.
  *
  * @version	1.00, 2001/06/26
  * @author 	Heiko Blau
@@ -56,10 +57,8 @@ public class ExtRuntimeException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
    */
@@ -78,6 +77,28 @@ public class ExtRuntimeException
     return _isWrapper;
   }
   
+  /**
+   * Getting the format string of a exception message. This can also be the 
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
   
   //---------------------------------------------------------------------------
   // constructors
@@ -151,10 +172,16 @@ public class ExtRuntimeException
    * @param fmt   exception message
    * @param args  arguments for the given format string
    */
-  public ExtRuntimeException(Exception ex, String msg, Object[] args) {
-    super(msg);
-    _next      = ex;
-    _isWrapper = true;
+  public ExtRuntimeException(Exception ex, String fmt, Object[] args) {
+    super(fmt);
+   
+    if (ex != null && fmt == null) {
+      _isWrapper = true;
+    } else {
+      _isWrapper = false;
+    }
+    _next = ex;
+    _args = args;
   }
   
   
@@ -163,37 +190,35 @@ public class ExtRuntimeException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.Throwable#getMessage} method. It
+   * delegates the call to the central {@link ExceptionMessageFormatter#getMessage}
+   * method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
+   * @see     ExceptionMessageFormatter
    */
   public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-      
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
   }
   
-  
   //---------------------------------------------------------------------------
   // members
   //
+  
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/java/util/AbstractTokenizer.java b/susebox/java/util/AbstractTokenizer.java
index 9de7264..8a0e829 100644
--- a/susebox/java/util/AbstractTokenizer.java
+++ b/susebox/java/util/AbstractTokenizer.java
@@ -1268,6 +1268,25 @@ __MAIN_LOOP__:
     return new String(_inputBuffer, start - _rangeStart, len);
   }
   
+
+  /**
+   * Retrieve text from the currently available range. The start and length
+   * parameters must be inside {@link #getRangeStart} and
+   * <CODE>getRangeStart + {@link #currentlyAvailable}</CODE>. 
+   *<br>
+   * In contrast to the {@link #getText} method this one does not check for 
+   * correct parameters. Two situations may arise:<br> 
+   *   an {@link java.util.IndexOutOfBoundsException may occure<br>
+   *   uninitialized data may be retrieved
+   *
+   * @param   start   position where the text begins
+   * @param   len     length of the text
+   * @return  the text beginning at the given position ith the given length
+   */
+  public String getTextUnchecked(int start, int len) {
+    return new String(_inputBuffer, start - _rangeStart, len);
+  }
+  
   /**
    * Get a single character from the current text range.
    *
@@ -1516,6 +1535,40 @@ __MAIN_LOOP__:
     return prop;
   }
 
+
+  /**
+   * This method checks if the character sequence starting at a given position
+   * with a given lenght is a keyword. If so, it returns the keyword description
+   * as {@link TokenizerProperty} object.
+   *<br>
+   * If the method needs to build a string from the character sequence it may
+   * use {@link #getText} or {@link #getTextUnchecked} to retrieve it.
+   *<br>
+   * This method is should be overwritten by derived classes having their own
+   * keyword handling.
+   *
+   * @param   startingAtPos   check at this position
+   * @param   length          the candidate has this number of characters
+   * @return  {@link TokenizerProperty} describing the keyword or <code>null</code>
+   */
+  protected TokenizerProperty isKeyword(int startingAtPos, int length) {
+    TokenizerProperty prop = null;
+    
+    // test on keyword
+    if (_keywords[0] != null || _keywords[1] != null) {
+      String            keyword = new String(_inputBuffer, startingAtPos - _rangeStart, length);
+      
+      if (_keywords[0] != null) {
+        prop = (TokenizerProperty)_keywords[0].get(keyword);
+      }
+      if (prop == null && _keywords[1] != null) {
+        keyword = keyword.toUpperCase();
+        prop    = (TokenizerProperty)_keywords[1].get(keyword);
+      }
+    }
+    return prop;
+  }
+  
   
   //---------------------------------------------------------------------------
   // Implementation
@@ -1704,29 +1757,15 @@ __MAIN_LOOP__:
     }
     
     // test on keyword
-    if (_keywords[0] != null || _keywords[1] != null) {
-      TokenizerProperty prop    = null;
-      String            keyword = new String(_inputBuffer, _currentReadPos, len);
-      
-      if (_keywords[0] != null) {
-        prop = (TokenizerProperty)_keywords[0].get(keyword);
-      }
-      if (prop == null && _keywords[1] != null) {
-        keyword = keyword.toUpperCase();
-        prop    = (TokenizerProperty)_keywords[1].get(keyword);
-      }
-      if (prop != null) {
-        token.setType(Token.KEYWORD); 
-        token.setLength(keyword.length());
-        token.setCompanion(prop.getCompanion());
-      } else {
-        token.setType(Token.NORMAL);
-        token.setLength(len);
-      }
+    TokenizerProperty prop = isKeyword(_currentReadPos + _rangeStart, len);
+    
+    if (prop != null) {
+      token.setType(Token.KEYWORD); 
+      token.setCompanion(prop.getCompanion());
     } else {
       token.setType(Token.NORMAL);
-      token.setLength(len);
     }
+    token.setLength(len);
     return true;
   }
   
diff --git a/susebox/java/util/Token.java b/susebox/java/util/Token.java
index cc1ffad..0471373 100644
--- a/susebox/java/util/Token.java
+++ b/susebox/java/util/Token.java
@@ -54,23 +54,23 @@ public class Token {
   /**
    * The token is nothing special (no keyword, no whitespace, etc.).
    */  
-  public static final int NORMAL = 0;
+  public static final byte NORMAL = 0;
 
   /**
    * The token is a keyword registered with the used {@link Tokenizer}.
    */  
-  public static final int KEYWORD = 1;
+  public static final byte KEYWORD = 1;
 
   /**
    * The token is one of the quoted strings known to the {@link Tokenizer}. In Java
    * this would be for instance a "String" or a 'c' (haracter).
    */  
-  public static final int STRING = 2;
+  public static final byte STRING = 2;
   
   /**
    * If a {@link Tokenizer} recognizes numbers, this token is one.
    */  
-  public static final int NUMBER = 3;
+  public static final byte NUMBER = 3;
   
   /**
    * Special sequences are characters or character combinations that have a certain
@@ -79,14 +79,14 @@ public class Token {
    * A companion might have been associated with a special sequence. It probably
    * contains information important to the user of the <CODE>Token</CODE>.
    */  
-  public static final int SPECIAL_SEQUENCE = 4;
+  public static final byte SPECIAL_SEQUENCE = 4;
   
   /** 
    * Separators are otherwise not remarkable characters. An opening parenthesis 
    * might be nessecary for a syntactically correct text, but without any special 
    * meaning to the compiler, interpreter etc. after it has been detected.
    */  
-  public static final int SEPARATOR = 5;
+  public static final byte SEPARATOR = 5;
   
   /** 
    * Whitespaces are portions of the text, that contain one or more characters 
@@ -94,31 +94,31 @@ public class Token {
    * whitespaces is equally represented by one single whitespace character. That 
    * is the difference to separators.
    */  
-  public static final int WHITESPACE = 6;
+  public static final byte WHITESPACE = 6;
 
   /**
    * Although a line comment is - in most cases - actually a whitespace sequence, it
    * is often nessecary to handle it separately. Syntax hilighting is a thing that
    * needs to know a line comment.
    */  
-  public static final int LINE_COMMENT = 7;
+  public static final byte LINE_COMMENT = 7;
 
   /**
    * Block comments are also a special form of a whitespace sequence. See 
    * {@link #LINE_COMMENT} for details.
    */  
-  public static final int BLOCK_COMMENT = 8;
+  public static final byte BLOCK_COMMENT = 8;
 
   /**
    * A token of the type <CODE>EOF</CODE> is used to indicate an end-of-line condition
    * on the input stream of the tokenizer.
    */  
-  public static final int EOF = -1;
+  public static final byte EOF = -1;
   
   /**
    * This is for the leftovers of the lexical analysis of a text.
    */  
-  public static final int UNKNOWN = -2;
+  public static final byte UNKNOWN = -2;
     
 
   //---------------------------------------------------------------------------
diff --git a/susebox/java/util/Tokenizer.java b/susebox/java/util/Tokenizer.java
index b74333b..39b3ae0 100644
--- a/susebox/java/util/Tokenizer.java
+++ b/susebox/java/util/Tokenizer.java
@@ -196,7 +196,7 @@ public interface Tokenizer
    * Without this flag, comparison is done like in Java or C/C++. When the flag 
    * is set, the tokenizer compares tokens like in HTML or PL/SQL.
    */
-  public static final int F_NO_CASE               = 0x0001;
+  public static final short F_NO_CASE               = 0x0001;
 
   /**
    * In case that the <CODE>F_NO_CASE</CODE> flag is set, this flag is used to
@@ -204,7 +204,7 @@ public interface Tokenizer
    * The combination between <CODE>F_NO_CASE</CODE> and <CODE>F_KEYWORDS_CASE</CODE>
    * means, that keywords are case-sensitive but everything else is not.
    */
-  public static final int F_KEYWORDS_CASE         = 0x0002;
+  public static final short F_KEYWORDS_CASE         = 0x0002;
   
   /**
    * In case that the <CODE>F_NO_CASE</CODE> flag is not set, this flag is used 
@@ -212,44 +212,44 @@ public interface Tokenizer
    * The flag <CODE>F_KEYWORDS_NO_CASE</CODE> means, that keywords are not 
    * case-sensitive but everything else is.
    */
-  public static final int F_KEYWORDS_NO_CASE      = 0x0004;
+  public static final short F_KEYWORDS_NO_CASE      = 0x0004;
   
   /**
    * In many cases, parsers are not interested in whitespaces. If You are, use
    * this flag to force the tokenizer to return whitespace sequences as a token.
    */
-  public static final int F_RETURN_WHITESPACES    = 0x0008;
+  public static final short F_RETURN_WHITESPACES    = 0x0008;
   
   /**
    * For perfomance and memory reasons, this flag is used to avoid copy operations
    * for every token. The token image itself is not returned in a {@link Token}
    * instance, only its position and length in the input stream.
    */
-  public static final int F_TOKEN_POS_ONLY        = 0x0010;
+  public static final short F_TOKEN_POS_ONLY        = 0x0010;
 
   /**
    * Set this flag to let the tokenizer buffer all data. Normally, a tokenizer
    * keeps only a certain amount of periodically changing data in its internal 
    * buffer.
    */
-  public static final int F_KEEP_DATA             = 0x0020;
+  public static final short F_KEEP_DATA             = 0x0020;
 
   /**
    * Tells the tokenizer to count lines and columns. The tokenizer may use
    * System.getProperty("line.separator") to obtain the end-of-line sequence.
    */
-  public static final int F_COUNT_LINES           = 0x0040;
+  public static final short F_COUNT_LINES           = 0x0040;
 
   /**
    * Nested block comments are normally not allowed. This flag changes the 
    * default behaviour
    */
-  public static final int F_ALLOW_NESTED_COMMENTS = 0x0080;
+  public static final short F_ALLOW_NESTED_COMMENTS = 0x0080;
   
   /**
    * With this flag, the tokenizer tries to identify numbers.
    */
-  public static final int F_PARSE_NUMBERS         = 0x0100;
+  public static final short F_PARSE_NUMBERS         = 0x0100;
 
 
   //---------------------------------------------------------------------------
diff --git a/susebox/java/util/TokenizerException.java b/susebox/java/util/TokenizerException.java
index 118710a..dbf87d3 100644
--- a/susebox/java/util/TokenizerException.java
+++ b/susebox/java/util/TokenizerException.java
@@ -33,9 +33,8 @@ package de.susebox.java.util;
 //------------------------------------------------------------------------------
 // Imports
 //
-
-import java.text.MessageFormat;
 import de.susebox.java.lang.ExceptionList;
+import de.susebox.java.lang.ExceptionMessageFormatter;
 
 
 //------------------------------------------------------------------------------
@@ -63,13 +62,11 @@ public class TokenizerException
   //
   
   /**
-   * Method to traverse the exception list. By convention, <CODE>nextException</CODE>
-   * returns the "earlier" exception. By walking down the exception list one gets the
-   * the following meaning:<br>
-   * this happened because nextException happened because nextException happened...
+   * Method to traverse the exception list. See {@link de.susebox.java.lang.ExceptionList#nextException}
+   * for details.
    *
    * @return the "earlier" exception
-   */  
+   */
   public Exception nextException() {
 		return _next;
 	}
@@ -85,6 +82,28 @@ public class TokenizerException
 		return _isWrapper;
 	}
 
+  /**
+   * Getting the format string of a exception message. This can also be the
+   * message itself if there are no arguments.
+   *
+   * @return  the format string being used by {@link java.text.MessageFormat}
+   * @see     #getArguments
+   */
+  public String getFormat() {
+    return super.getMessage();
+  }  
+  
+  /**
+   * Retrieving the arguments for message formats. These arguments are used by
+   * the {@link java.text.MessageFormat#format} call.
+   *
+   * @return  the arguments for a message format
+   * @see     #getFormat
+   */
+  public Object[] getArguments() {
+    return _args;
+  }
+  
   
   //---------------------------------------------------------------------------
   // constructors
@@ -158,14 +177,15 @@ public class TokenizerException
    * @param args  arguments for the given format string
    */  
 	public TokenizerException(Exception ex, String fmt, Object[] args) {
-		super(fmt);
-    
+    super(fmt);
+   
     if (ex != null && fmt == null) {
       _isWrapper = true;
     } else {
       _isWrapper = false;
     }
     _next = ex;
+    _args = args;
 	}
 
 
@@ -174,38 +194,35 @@ public class TokenizerException
   //
   
   /**
-   * Implementation of the standard {@link java.Throwable#getMessage} method to 
-   * meet the requirements of formats and format arguments as well as wrapper
-   * exceptions.
-   * If this is a wrapper exception then the <CODE>getMessage</CODE> of the wrapped 
-   * exception is returned.
-   * If no arguments were given in the constructor then the format parameter is
-   * taken as the formatted message itself. Otherwise it is treated like the
-   * patter for the {@link java.text.MessageFormat#format} method.
+   * Implementation of the standard {@link java.langThrowable#getMessage} method. It
+   * delegates the call to the central 
+   * {@link de.susebox.java.lang.ExceptionMessageFormatter#getMessage} method.
    *
    * @return  the formatted exception message
-   * @see     java.text.MessageFormat
-   */  
+   * @see     de.susebox.java.lang.ExceptionMessageFormatter
+   */
 	public String getMessage() {
-    if (isWrapperException()) {
-      return nextException().getMessage();
-    } else {
-      String fmt = super.getMessage();
-
-      if (_args == null) {
-        return fmt;
-      } else {
-        return MessageFormat.format(fmt, _args);
-      }
-    }
+    return ExceptionMessageFormatter.getMessage(this);
 	}
 
-  
-  
   //---------------------------------------------------------------------------
   // members
   //
+
+  /**
+   * the parameters to be used when formatting the exception message
+   */
   protected Object[]  _args       = null;
+
+  /**
+   * The wrapped, nested of next exception.
+   */
   protected Exception _next       = null;
+  
+  /**
+   * If <code>true</code> this is only a wrapper exception with the real one
+   * being returned by {@link #nextException}, <code>false</code> for standalone, 
+   * nested or subsequent exceptions
+   */
   protected boolean   _isWrapper  = false;
 }
diff --git a/susebox/jtopas/InputStreamSource.java b/susebox/jtopas/InputStreamSource.java
index bcc780c..a2aae03 100644
--- a/susebox/jtopas/InputStreamSource.java
+++ b/susebox/jtopas/InputStreamSource.java
@@ -70,8 +70,8 @@ public class InputStreamSource implements TokenizerSource {
    * A basic method to supply data to a {@link de.susebox.java.util.Tokenizer}.
    *
    * @param cbuf      buffer to receive data
-   * @param offset    position from where the data should be inserted in <CODE>cbuf</CODE>
-   * @param maxChars  maximum number of characters to be read into <CODE>cbuf</CODE>
+   * @param offset    position from where the data should be inserted in <code>cbuf</code>
+   * @param maxChars  maximum number of characters to be read into <code>cbuf</code>
    * @return actually read characters or -1 on an end-of-file condition
    * @throws Exception anything that could happen during read, most likely {@link java.io.IOException}
    */
@@ -107,7 +107,7 @@ public class InputStreamSource implements TokenizerSource {
 
   /**
    * Constructor that takes a instantiated {@link java.io.Reader}. If 
-   * <CODE>null</CODE> is given then standard input is used (see {@link java.lang.System#in}).
+   * <code>null</code> is given then standard input is used (see {@link java.lang.System#in}).
    *
    * @param Reader   input stream to be used for reading
    * @see   java.io.Reader
@@ -119,9 +119,9 @@ public class InputStreamSource implements TokenizerSource {
   /**
    * Constructor that takes a instantiated {@link java.io.Reader} and the
    * tokenizer control flags.
-   * If <CODE>null</CODE> is given for the stream then standard input is used 
+   * If <code>null</code>> is given for the stream then standard input is used 
    * (see {@link java.lang.System#in}).
-   * For the tokenizer control flags use a combination of the <CODE>F_...</CODE>
+   * For the tokenizer control flags use a combination of the <code>F_...</code>
    * constants from the {@link Tokenizer} for this parameter.
    *
    * @param reader   input stream to be used for reading
@@ -166,5 +166,9 @@ public class InputStreamSource implements TokenizerSource {
   //---------------------------------------------------------------------------
   // Members
   //
+  
+  /**
+   * The {@link java.io.Reader} instance that does the actual reading.
+   */
   protected Reader _reader = null;
 }
diff --git a/susebox/jtopas/Plugin.java b/susebox/jtopas/Plugin.java
index d8e4899..61edb1d 100644
--- a/susebox/jtopas/Plugin.java
+++ b/susebox/jtopas/Plugin.java
@@ -37,6 +37,8 @@ package de.susebox.jtopas;
 
 /**<p>
  * This is the base interface for all handler pluggins in the {@link PluginTokenizer}.
+ * Since generally plugins need to know their parent <code>Tokenizer</code>, this
+ * interface is provided to pass that instance to the plugin.
  *</p>
  *
  * @see     de.susebox.java.util.Tokenizer
diff --git a/susebox/jtopas/PluginTokenizer.java b/susebox/jtopas/PluginTokenizer.java
index 7622f08..a38f6b8 100644
--- a/susebox/jtopas/PluginTokenizer.java
+++ b/susebox/jtopas/PluginTokenizer.java
@@ -163,6 +163,33 @@ public class PluginTokenizer extends AbstractTokenizer {
   }
   
   
+  /**
+   * Setting a new {@link KeywordHandler} or removing any previously installed
+   * one. If <code>null</code> is passed (installed handler removed), the 
+   * tokenizer will fall back to the base implementation.
+   *
+   * @param handler   the (new) {@link KeywordHandler} to use or null to remove it
+   */
+  public void setKeywordHandler(KeywordHandler handler) {
+    if ((_keywordHandler = handler) != null) {
+      _keywordHandler.setTokenizer(this);
+    }
+  }
+  
+  /**
+   * Retrieving the current {@link KeywordHandler}. The method may return
+   * <code>null</code> if there isn't any handler installed. That does not
+   * mean, that keywords are not dealt with. Keyword detection is done by the 
+   * base method of {@link de.susebox.java.util.AbstractTokenizer} in that case.
+   *
+   * @return  the currently active whitespace keyword or null, if the base
+   *          implementation is working
+   */
+  public KeywordHandler getKeywordHandler() {
+    return _keywordHandler;
+  }
+  
+  
   /**
    * Setting a new {@link WhitespaceHandler} or removing any previously installed
    * <code>WhitespaceHandler</code>. If <code>null</code> is passed, the tokenizer
@@ -248,6 +275,26 @@ public class PluginTokenizer extends AbstractTokenizer {
   // Overridden methods of AbstractTokenizer
   //
   
+  /**
+   * This method checks if the character sequence starting at a given position
+   * with a given lenght is a keyword. If so, it returns the keyword description
+   * as {@link TokenizerProperty} object.
+   * If the method needs to build a string from the character sequence it may
+   * use {@link #getText} or {@link #getTextUnchecked} to retrieve it.
+   *
+   * @param   startingAtPos check at this position
+   * @param   length        the candidate has this number of characters
+   * @return  {@link TokenizerProperty} describing the keyword or <code>null</code>
+   */
+  protected TokenizerProperty isKeyword(int startingAtPos, int length) {
+    if (_keywordHandler != null) {
+      return _keywordHandler.isKeyword(startingAtPos, length);
+    } else {
+      return super.isKeyword(startingAtPos, length);
+    }
+  }
+    
+  
   /**
    * This method checks if the character is a whitespace. It will use an installed
    * {@link WhitespaceHandler} or switch back to the base implementation.
@@ -354,4 +401,5 @@ public class PluginTokenizer extends AbstractTokenizer {
   private WhitespaceHandler _whitespaceHandler = null;
   private SeparatorHandler  _separatorHandler  = null;
   private SequenceHandler   _sequenceHandler   = null;
+  private KeywordHandler    _keywordHandler    = null;
 }
 